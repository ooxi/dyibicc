From luajit 2.1 at 505e2c03de35e2718eef0d2d3660712e06dadf1f with two small
patches. The first is:

--- a/dynasm.lua
+++ b/dynasm.lua
@@ -829,7 +829,7 @@ local function doline(line)
   if g_opt.flushline then wflush() end

   -- Assembler line?
-  local indent, aline = match(line, "^(%s*)%|(.*)$")
+  local indent, aline = match(line, "^(%s*)%///|(.*)$")
   if not aline then
     -- No, plain C code line, need to flush first.
     wflush()


to make the dynasm prefix ///| rather than |.

This is so that clang-format doesn't destroy things when dynasm lines get
formatted. LuaJIT's jit is written primarily in asm assembled by DynASM and
there's only an occasional sprinkle of C, so having only | as a prefix makes
sense. Here though, the code is mostly C with a sprinkle of DynASM (handling the
messy encoding details), so it makes more sense to integrate the asm in special
C-comments.

Additionally something like this is nice in .vimrc to highlight dynasm lines:

autocmd BufRead,BufEnter *.in.c syn region cDynasm start="^\s*\(///|\)" skip="\\$" end="$" keepend
autocmd BufRead,BufEnter *.in.c hi def link cDynasm SpecialChar

A second patch is also added to add `os.system` and `os.tmpnam` to minilua:

diff --git a/dynasm/minilua.c b/dynasm/minilua.c
index 76f32ae..1cf3290 100644
--- a/dynasm/minilua.c
+++ b/dynasm/minilua.c
@@ -6983,12 +6983,27 @@ static int os_remove(lua_State*L){
 const char*filename=luaL_checkstring(L,1);
 return os_pushresult(L,remove(filename)==0,filename);
 }
+static int os_execute(lua_State *L) {
+lua_pushinteger(L,system(luaL_optstring(L, 1, NULL)));
+return 1;
+}
 static int os_exit(lua_State*L){
 exit(luaL_optint(L,1,EXIT_SUCCESS));
 }
+static int os_tmpname(lua_State *L) {
+char buff[L_tmpnam];
+int err;
+err=(tmpnam(buff) == NULL);
+if (err)
+return luaL_error(L,"unable to generate a unique filename");
+lua_pushstring(L,buff);
+return 1;
+}
 static const luaL_Reg syslib[]={
+{"execute",os_execute},
 {"exit",os_exit},
 {"remove",os_remove},
+{"tmpnam",os_tmpname},
 {NULL,NULL}
 };
 static int luaopen_os(lua_State*L){

This is to be able to use minilua to run the tests (in particular negative ones
which require a bit of text parsing to determine if errors are correctly
emitted.)
